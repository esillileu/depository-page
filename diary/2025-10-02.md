---
tags:
  - diary
---
# 주요 작업 및 결과
- [[NVIDIA AI ACADEMY]] 파이썬 공부
	- 코루틴 (async, await)
		- 이벤트 루프 안에서 실행을 멈췄다 특정 조건에서 이어할 수 있는 함수
			- 반드시 이벤트 루프 안에서만 실행
		- 이벤트 루프
			- 레디 큐, 타이머 큐, io 와쳐 존재
				- 태스크 등록 시 재개 조건에 따라 테스크 콜백 등록
				- 레디큐 
					- 테스크 콜백 저장
					- 이벤트 루프가 제어권 가지면 즉시 테스크 콜백 으로 테스크 실행
				- 타이머 큐 
					- 타이머 조건, 테스크 콜백 저장
					- 달성시 테스크 콜백을 레디큐로 이동
				- io와쳐 
					- io 조건, 테스크 콜백 저장
					- 달성시 테스크 콜백을 레디큐로 이동
			- 이벤트 루프는 폴링으로 조건을 확인하는 것이 아니라 태크의 조건을 os에 알림으로 등록. 이후 제어권을 갖게 되면 실행하며 알림에 대한 콜백 처리 
			- 이벤트 루프는 등록된 테스크를 모두 실행하면 종료
				- 외부 이벤트 기다리게도 가능
			- 코루틴을 실행하기 위해서는 코루틴 객체를 테스크로 감싸 등록
			- 테스크 실행 후 콜백 처리 
		- await 
			- 실행 제어권을 이벤트 루프로 넘김 
			- 다음에 오는 awaitable 객체의 완료 콜백을 현재 코루틴 재개 조건 연결
				- 테스크, 퓨처 - 이미 연결되어있어 등록없이 연결
				- 코루틴 - 테스크로 등록하고 연결
			- 코루틴 객체로 현재 프레임 저장
			- 현재 함수 스택에서 내림
	+ 파이썬의 실행은 일반적으로 호출자에게 실행 제어권이 있음
		+ 피호출자 호출시 스택에 프레임을 쌓아 피호출자에게 제어권 넘김
		+ 피호출자 종료시 제어권 반환
		+ 루트 프레임(`__main__`)이 최초 호출자
		+ await 만나면 이벤트 루프가 제어권을 가지면서 반환 전까지 레디 큐에 있는 재개 조건 달성한 테스크 실행
	+ 스레딩
		+ 코드, 데이터, 힙영역은 공유하나 스택영역이 구분되는 실행단위
		+ OS 자체에서 할당하는 스레드를 파이썬 객체로 관리
		+ 스레드 자체는 os레벨로 생성되어 대기열에 등록되나, 파이썬 자체 GIL로 인해 하나 씩만 실행
			+ 여러 코어에 스레드가 스케쥴링 될 수 있음
			+ GIL이 없으면 스케쥴링은 되나, 인터프리터 루프로 진입하지 못해 blocked 상태로 전환
			+ GIL 흭득시 실행
		+ 서로 다른 스레드의 스택에는 접근 불가
			+ 다른 프로그램의 경우 스레드가 다른스레드 강제 종료 가능
				+ 스레드가 다른 스레드의 실행 컨덱스트 반환 요청
			+ 파이썬은 불가능
				+ GIL, 안정성으로 강제종료 불가 
# 한담
- [[NVIDIA AI ACADEMY]] 파이썬 공부
	- 코루틴은 진짜 너무 어렵다. 이게 본적이 별로 없으니까 이해가 잘 안되는게 엄청 크다. 이벤트 루프니 코루틴이니 재실행이니 머깨질뻔 했다. 역대 배운 개념 중에 제일 많고 방대한 것 같다. 죽겠다. 차라리 데코레이터를 줘라 
	- 저 흐름제어 3종세트 엮어서 프로젝트를 진행해야겠다는 생각. 이헤가 잘 안된다. 